/**
 * @file main.c
 * @brief STM32 Bootloader主程序 - 支持OTA固件更新功能
 * @details 本程序实现了一个双分区Bootloader，支持从外部Flash(W25Q64)读取新固件
 *          并更新到STM32内部Flash的A分区，实现安全的固件升级功能
 * @author 无敌雪碧
 * @date 2025.10.1
 */

// ==============================================================================
// 头文件包含
// ==============================================================================
#include "stm32f10x.h"                  // STM32F10x标准外设库头文件
#include "usart.h"                      // 串口通信驱动（命令行、日志、XMODEM收发）
#include "delay.h"                      // 延时函数库（用于心跳节拍、超时等待）
#include "AT24C02.h"                    // AT24C02 EEPROM驱动（存储OTA元数据）
#include "W25Q64.h"                     // W25Q64 SPI Flash驱动（外部固件仓库）
#include "main.h"                       // 主程序头文件(定义常量和数据结构)
#include "boot.h"                       // Bootloader功能头文件（分支、跳转、XMODEM）
#include "fm.h"                         // Flash管理头文件（擦写内部Flash）

// ==============================================================================
// 全局变量定义
// ==============================================================================
OTA_InfoCB OTA_Info;                    // OTA信息控制块，持久化在AT24C02，启动时读入RAM
UpDataA_CB UpDataA;                     // A区更新控制块，运行期状态（RAM）
uint32_t BootStaFlag;                   // 系统状态机标志位（位组合，参见 main.h）

uint8_t aaa[5] = {0x01,0x02,0x03,0x04,0x05};

/**
 * @brief STM32 Bootloader主函数
 * @details 启动序列：
 *          1) 初始化基础外设（时基、串口、外部与EEPROM存储）。
 *          2) 读取AT24C02中的OTA信息（版本、更新标志、外部仓库各块长度）。
 *          3) 进入分支：若要求OTA，则标记更新并留在Boot；否则跳转到A区应用。
 *          4) 若停留在Boot命令行，则处理交互命令（擦除/下载/版本/搬运/重启）。
 *          5) 若触发从外部仓库搬运到A区，则执行页擦写与搬运后复位。
 */
int main(void)
{	
	uint8_t i = 0;                      // 循环计数器，用于分页处理
	
	// ==========================================================================
	// 系统初始化阶段
	// ==========================================================================
	Delay_Init();                       // 初始化系统延时函数（依赖SysTick或定时器）
	USART1_Init(921600);                // 初始化串口1：较高波特率加速XMODEM/日志
	AT24C02_Init();                     // 初始化AT24C02：后续读取/写入OTA信息
	W25Q64_Init();                      // 初始化外部SPI Flash：作为固件仓库
	// ==========================================================================
	// 读取OTA配置信息
	// ==========================================================================
	AT24C02_ReadOTAInfo();              // 从EEPROM读取OTA信息(固件长度、更新标志、版本)

	


	// ==========================================================================
	// 启动分支判断（可能跳转，若未跳转则进入命令行）
	// ==========================================================================
	BootLoader_Brance();                // 根据OTA标志决定启动流程：
	                                    // - 如果OTA_flag=1：设置更新标志，准备OTA更新
	                                    // - 如果OTA_flag=0：直接跳转到A分区执行应用程序

	// ==========================================================================
    // 主循环 - 命令行处理/XMODEM心跳/外部仓库到A区搬运
	// ==========================================================================
	while (1)
	{
		Delay_ms(10);
		// 串口环形缓冲区有新数据：驱动命令解析与XMODEM帧处理
		if(U0CB.URxDataOUT != U0CB.URxDataIN)
		{
			BootLoader_Event(U0CB.URxDataOUT->start,U0CB.URxDataOUT->end - U0CB.URxDataOUT->start + 1);
			U0CB.URxDataOUT ++;
			if(U0CB.URxDataOUT >= U0CB.URxDataEND)
			{
				U0CB.URxDataOUT = &U0CB.URxDataPtr[0];
			}


		}

		// XMODEM“招手”心跳：每 ~100ms 发送一次 'C' 以提示对端开始/继续
		if(BootStaFlag & IAP_XMODEMC_FLAG)
		{
		    if(UpDataA.XmodemTimer >= 100)
			{
				printf("C\n");
				UpDataA.XmodemTimer = 0;


			}
			UpDataA.XmodemTimer++;
		}













		// 检查是否需要从外部仓库更新A分区固件（命令6触发，或OTA搬运）
		if(BootStaFlag & UPDATA_A_FLAG)
		{
		    // ==================================================================
		    // A分区固件更新流程（从W25Q64指定块顺序读取，分页写入内部Flash）
		    // ==================================================================
			printf("长度 %d 字节",OTA_Info.Firelen[UpDataA.W25Q64_BlockNB]);

			// 验证固件长度是否为4的倍数(STM32 Flash写入要求)
			if(OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % 4 == 0)
			{
				// ==============================================================
				// 擦除A分区Flash
				// ==============================================================
				STM32_EraseFlash(STM32_A_START_PAGE,STM32_A_PAGE_NUM);
				// 从第20页开始擦除44页，为A分区腾出空间(0x08005000-0x0800FFFF)
				
				// ==============================================================
				// 分页读取和写入固件数据
				// ==============================================================
			    for(i = 0;i < OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] / STM32_PAGE_SIZE;i++)
				{
					// 从W25Q64外部Flash读取数据到缓冲区
					// 地址计算：i * 1024 + UpDataA.W25Q64_BlockNB * 64 * 1024
					// - i * 1024：当前页在固件中的偏移量(每页1KB)
					// - UpDataA.W25Q64_BlockNB * 64 * 1024：当前块在W25Q64中的偏移量(每块64KB)
					W25Q64_Read(UpDataA.UpdataBuff,i *1024 + UpDataA.W25Q64_BlockNB * 64 * 1024,STM32_PAGE_SIZE);
					
					// 将数据写入STM32内部Flash的A分区
					// 目标地址：0x08005000 + i * STM32_PAGE_SIZE
					STM32_WriteFlash(STM32_A_SADDR + i * STM32_PAGE_SIZE,(uint32_t *)UpDataA.UpdataBuff,STM32_PAGE_SIZE);
				}
				
				// ==============================================================
				// 处理剩余不足一页的数据
				// ==============================================================
				if(OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE != 0)
				{
					// 读取剩余数据(不足1024字节的部分)
					W25Q64_Read(UpDataA.UpdataBuff,i *1024 + UpDataA.W25Q64_BlockNB * 64 * 1024,OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE);
					// 写入剩余数据到Flash
					STM32_WriteFlash(STM32_A_SADDR + i * STM32_PAGE_SIZE,(uint32_t *)UpDataA.UpdataBuff,OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE);
				}
				
				// ==============================================================
				// 更新完成处理
				// ==============================================================
				if(UpDataA.W25Q64_BlockNB == 0)
				{
				    // 只有在处理第一个块(Block 0)时才执行清理操作
				    // 确保清理操作只执行一次，避免重复操作
				    OTA_Info.OTA_flag = 0;           // 清除OTA更新标志
					AT24C02_WriteOTAInfo();          // 将OTA信息保存到EEPROM
				}
				printf("A区更新完毕\r\n");
				// ==============================================================
				// 系统复位，让新固件生效
				// ==============================================================
				NVIC_SystemReset();                  // 强制系统复位，重启后新固件开始运行

			}
			else
			{
			    // ==============================================================
			    // 固件长度错误处理
			    // ==============================================================
			    printf("长度错误\r\n");              // 输出错误信息
				BootStaFlag &= ~UPDATA_A_FLAG;      // 清除更新标志，退出更新流程
			}
		}
	}
}
