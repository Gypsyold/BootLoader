/**
 * @file main.c
 * @brief STM32 Bootloader主程序 - 支持OTA固件更新功能
 * @details 本程序实现了一个双分区Bootloader，支持从外部Flash(W25Q64)读取新固件
 *          并更新到STM32内部Flash的A分区，实现安全的固件升级功能
 * @author 无敌雪碧
 * @date 2025.10.1
 */

// ==============================================================================
// 头文件包含
// ==============================================================================
#include "stm32f10x.h"                  // STM32F10x标准外设库头文件
#include "usart.h"                      // 串口通信驱动
#include "delay.h"                      // 延时函数库
#include "AT24C02.h"                    // AT24C02 EEPROM驱动
#include "W25Q64.h"                     // W25Q64 SPI Flash驱动
#include "main.h"                       // 主程序头文件(定义常量和数据结构)
#include "boot.h"                       // Bootloader功能头文件
#include "fm.h"                         // Flash管理头文件

// ==============================================================================
// 全局变量定义
// ==============================================================================
OTA_InfoCB OTA_Info;                    // OTA信息控制块，存储固件长度和更新标志
UpDataA_CB UpDataA;                     // A区更新控制块，包含数据缓冲区和块号
uint32_t BootStaFlag;                   // 系统启动状态标志位

/**
 * @brief STM32 Bootloader主函数
 * @details 实现双分区Bootloader功能：
 *          1. 系统初始化
 *          2. 读取OTA配置信息
 *          3. 根据OTA标志决定启动流程
 *          4. 执行固件更新或跳转到应用程序
 * @param 无
 * @retval 无
 */
int main(void)
{	
	uint8_t i = 0;                      // 循环计数器，用于分页处理
	
	// ==========================================================================
	// 系统初始化阶段
	// ==========================================================================
	Delay_Init();                       // 初始化系统延时函数
	USART1_Init(921600);                // 初始化串口1，波特率921600，用于调试输出
	AT24C02_Init();                     // 初始化AT24C02 EEPROM，用于存储OTA配置信息

	// ==========================================================================
	// 读取OTA配置信息
	// ==========================================================================
	AT24C02_ReadOTAInfo();              // 从EEPROM读取OTA信息(固件长度、更新标志等)

	// ==========================================================================
	// 启动分支判断
	// ==========================================================================
	BootLoader_Brance();                // 根据OTA标志决定启动流程：
	                                    // - 如果OTA_flag=1：设置更新标志，准备OTA更新
	                                    // - 如果OTA_flag=0：直接跳转到A分区执行应用程序

	// ==========================================================================
	// 主循环 - OTA固件更新处理
	// ==========================================================================
	while (1)
	{
		// 检查是否需要更新A分区固件
		if(BootStaFlag & UPDATA_A_FLAG)
		{
		    // ==================================================================
		    // A分区固件更新流程
		    // ==================================================================
			printf("长度 %d 字节",OTA_Info.Firelen[UpDataA.W25Q64_BlockNB]);

			// 验证固件长度是否为4的倍数(STM32 Flash写入要求)
			if(OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % 4 == 0)
			{
				// ==============================================================
				// 擦除A分区Flash
				// ==============================================================
				STM32_EraseFlash(STM32_A_START_PAGE,STM32_A_PAGE_NUM);
				// 从第20页开始擦除44页，为A分区腾出空间(0x08005000-0x0800FFFF)
				
				// ==============================================================
				// 分页读取和写入固件数据
				// ==============================================================
			    for(i = 0;i < OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] / STM32_PAGE_SIZE;i++)
				{
					// 从W25Q64外部Flash读取数据到缓冲区
					// 地址计算：i * 1024 + UpDataA.W25Q64_BlockNB * 64 * 1024
					// - i * 1024：当前页在固件中的偏移量(每页1KB)
					// - UpDataA.W25Q64_BlockNB * 64 * 1024：当前块在W25Q64中的偏移量(每块64KB)
					W25Q64_Read(UpDataA.UpdataBuff,i *1024 + UpDataA.W25Q64_BlockNB * 64 * 1024,STM32_PAGE_SIZE);
					
					// 将数据写入STM32内部Flash的A分区
					// 目标地址：0x08005000 + i * STM32_PAGE_SIZE
					STM32_WriteFlash(0x08005000 + i * STM32_PAGE_SIZE,(uint32_t *)UpDataA.UpdataBuff,STM32_PAGE_SIZE);
				}
				
				// ==============================================================
				// 处理剩余不足一页的数据
				// ==============================================================
				if(OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE != 0)
				{
					// 读取剩余数据(不足1024字节的部分)
					W25Q64_Read(UpDataA.UpdataBuff,i *1024 + UpDataA.W25Q64_BlockNB * 64 * 1024,OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE);
					// 写入剩余数据到Flash
					STM32_WriteFlash(0x08005000 + i * STM32_PAGE_SIZE,(uint32_t *)UpDataA.UpdataBuff,OTA_Info.Firelen[UpDataA.W25Q64_BlockNB] % STM32_PAGE_SIZE);
				}
				
				// ==============================================================
				// 更新完成处理
				// ==============================================================
				if(UpDataA.W25Q64_BlockNB == 0)
				{
				    // 只有在处理第一个块(Block 0)时才执行清理操作
				    // 确保清理操作只执行一次，避免重复操作
				    OTA_Info.OTA_flag = 0;           // 清除OTA更新标志
					AT24C02_WriteOTAInfo();          // 将OTA信息保存到EEPROM
				}

				// ==============================================================
				// 系统复位，让新固件生效
				// ==============================================================
				NVIC_SystemReset();                  // 强制系统复位，重启后新固件开始运行

			}
			else
			{
			    // ==============================================================
			    // 固件长度错误处理
			    // ==============================================================
			    printf("长度错误\r\n");              // 输出错误信息
				BootStaFlag &= ~UPDATA_A_FLAG;      // 清除更新标志，退出更新流程
			}
		}
	}
}
