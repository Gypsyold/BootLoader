#include "stm32f10x.h"                  // Device header
#include "usart.h"
#include "delay.h"
#include "AT24C02.h"


uint8_t rdata_buff[256];
uint8_t wdata_buff1[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
//uint8_t wdata_buff2[8] = {0,1,2,3,4,5,6,7};
//uint8_t wdata_buff3[32] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};


int main(void)
{	
	Delay_Init();  			// 初始化SysTick延时函数
	USART1_Init(921600);	// 初始化串口
	AT24C02_Init();
	uint16_t i;
	
	printf("demo_1\r\n");	
	//验证单个字节写入
//	 for(i = 0; i < 256; i++)
//	 {
//	 	AT24C02_WriteByte(i, i);
//	 	Delay_ms(5);
//	 }

	//验证页写入
	for(i = 0;i<16;i++)  // 16页 × 16字节 = 256字节
	{
	    AT24C02_WritePage(i*16,wdata_buff1);  // 使用16字节数据，地址间隔16字节
	}

	AT24C02_ReadData(0,rdata_buff,256);
	
	for(i = 0; i < 256; i++)
	{
	    printf("地址%d = %x \r\n",i,rdata_buff[i]);
	}



	while (1)
	{

	}
}


/*

如果每页写32个字节的话，会在16出出现回滚，导致只有前16个字节有效，后面的字节无效
故该AT24C02是16字节写入的
[21:37:53.119] 地址0 = 10 
[21:37:53.119] 地址1 = 11 
[21:37:53.119] 地址2 = 12 
[21:37:53.119] 地址3 = 13 
[21:37:53.119] 地址4 = 14 
[21:37:53.119] 地址5 = 15 
[21:37:53.120] 地址6 = 16 
[21:37:53.120] 地址7 = 17 
[21:37:53.120] 地址8 = 18 
[21:37:53.120] 地址9 = 19 
[21:37:53.121] 地址10 = 1a 
[21:37:53.121] 地址11 = 1b 
[21:37:53.121] 地址12 = 1c 
[21:37:53.121] 地址13 = 1d 
[21:37:53.123] 地址14 = 1e 
[21:37:53.123] 地址15 = 1f 
[21:37:53.123] 地址16 = ff 
[21:37:53.123] 地址17 = ff 
[21:37:53.123] 地址18 = ff 
[21:37:53.123] 地址19 = ff 
[21:37:53.123] 地址20 = ff 
[21:37:53.123] 地址21 = ff 
[21:37:53.123] 地址22 = ff 
[21:37:53.123] 地址23 = ff 
[21:37:53.123] 地址24 = ff 
[21:37:53.123] 地址25 = ff 
[21:37:53.123] 地址26 = ff 
[21:37:53.123] 地址27 = ff 
[21:37:53.127] 地址28 = ff 
[21:37:53.127] 地址29 = ff 
[21:37:53.127] 地址30 = ff 
[21:37:53.127] 地址31 = ff 
[21:37:53.129] 地址32 = 10 
*/

